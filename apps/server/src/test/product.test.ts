import { faker } from "@faker-js/faker";
import type { inferProcedureInput } from "@trpc/server";

import { eq } from "drizzle-orm";
import { nanoid } from "nanoid";
import { beforeAll, describe, expect, it } from "vitest";
import { db } from "@/db";
import { productUom } from "@/db/schema/products";
import type { AppRouter } from "@/routers";
import { setupTestContext } from "./util";

describe("Testing Product Route", () => {
	let ctx: Awaited<ReturnType<typeof setupTestContext>>;

	beforeAll(async () => {
		ctx = await setupTestContext();
	});
	describe("testing product category route", () => {
		it("get all categories", async () => {
			const categories = await ctx.caller.product.category.getAll();
			expect(categories).toBeTruthy();
		});

		it("get category by code", async () => {
			const category = await ctx.caller.product.category.getByCode("public");
			expect(category).toBeTruthy();
			expect(category).toHaveProperty("code", "public");
		});

		it.sequential("create a category", async () => {
			const newCategory = {
				code: "NEW_CATEGORY",
				name: "New Category",
				organizationId: ctx.defaultOrg.id,
			};
			const [createdCategory] =
				await ctx.caller.product.category.create(newCategory);
			expect(createdCategory).toBeTruthy();
			expect(createdCategory).toHaveProperty("code", newCategory.code);
		});

		it.sequential("update a category", async () => {
			const categoryToUpdate =
				await ctx.caller.product.category.getByCode("NEW_CATEGORY");

			if (!categoryToUpdate) {
				throw new Error("Category not found");
			}
			const { id } = categoryToUpdate;

			await ctx.caller.product.category.update({
				id: id,
				code: "UPDATED_CATEGORY",
				name: "Updated Category",
				description: "this category was updated",
			});

			const categoryUpdated = await ctx.caller.product.category.getById(id);

			expect(categoryUpdated).toBeTruthy();
			expect(categoryUpdated).toHaveProperty("code", "UPDATED_CATEGORY");
			expect(categoryUpdated).toHaveProperty("name", "Updated Category");
		});

		it.sequential("delete a category", async () => {
			const categoryToDelete =
				await ctx.caller.product.category.getByCode("UPDATED_CATEGORY");

			if (!categoryToDelete) {
				throw new Error("Category not found");
			}

			await ctx.caller.product.category.delete(categoryToDelete.id);

			const deletedCategory = await ctx.caller.product.category.getById(
				categoryToDelete.id,
			);
			expect(deletedCategory).toBeFalsy();
		});
	});

	it("create a single product with EA base UOM", async () => {
		const input: inferProcedureInput<AppRouter["product"]["create"]> = {
			baseUom: "EA",
			name: faker.commerce.productName(),
			description: faker.commerce.productDescription(),
			sku: nanoid(10),
			productUoms: [
				{
					uomCode: "EA",
					qtyInBase: "1",
				},
				{
					uomCode: "PK",
					qtyInBase: "6",
				},
				{
					uomCode: "BX",
					qtyInBase: "36",
				},
			],
			attributes: {
				foo: "bar",
			},
			organizationId: ctx.defaultOrg.id,
			categoryId: ctx.defaultCategoryId,
			trackingLevel: "none",
		};

		const createdProduct = await ctx.caller.product.create(input);

		expect(createdProduct).toBeTruthy();
	});

	it("create a product with autogenerated product Uoms using uomConversion", async () => {
		const input: inferProcedureInput<AppRouter["product"]["create"]> = {
			baseUom: "EA",
			name: faker.commerce.productName(),
			description: faker.commerce.productDescription(),
			sku: nanoid(10),
			productUoms: [
				{
					uomCode: "PK",
				},
			],
			organizationId: ctx.defaultOrg.id,
			categoryId: ctx.defaultCategoryId,
		};

		const createdProduct = await ctx.caller.product.create(input);

		const pu = await db.query.productUom.findMany({
			where: eq(productUom.productId, createdProduct.id),
		});

		expect(createdProduct).toBeTruthy();
		expect(pu).toBeTruthy();
		expect(pu).toMatchObject([
			{
				uomCode: "PK",
				qtyInBase: "6.".padEnd(11, "0"),
			},
			{
				uomCode: "EA",
				qtyInBase: "1.".padEnd(11, "0"),
				isBase: true,
			},
		]);
	});

	it("create a product without productUoms", async () => {
		const input: inferProcedureInput<AppRouter["product"]["create"]> = {
			baseUom: "EA",
			name: faker.commerce.productName(),
			description: faker.commerce.productDescription(),
			sku: nanoid(10),
			organizationId: ctx.defaultOrg.id,
			categoryId: ctx.defaultCategoryId,
		};

		const createdProduct = await ctx.caller.product.create(input);

		expect(createdProduct).toBeTruthy();
		expect(createdProduct).toMatchObject({
			baseUom: "EA",
			isPhysical: true,
		});

		const pu = await db.query.productUom.findMany({
			where: eq(productUom.productId, createdProduct.id),
		});

		expect(pu).toBeTruthy();
		expect(pu).toMatchObject([
			{
				uomCode: "EA",
				qtyInBase: "1.000000000",
				isBase: true,
			},
		]);
	});

	it("Create a product with no stock (like service)", async () => {
		const input: inferProcedureInput<AppRouter["product"]["create"]> = {
			baseUom: "EA",
			name: "THIS IS A SERVICE",
			description: "THIS IS A SERVICE PRODUCT",
			sku: nanoid(10),
			organizationId: ctx.defaultOrg.id,
			categoryId: ctx.defaultCategoryId,
			isPhysical: false,
		};

		const createdProduct = await ctx.caller.product.create(input);

		expect(createdProduct).toBeTruthy();
		expect(createdProduct).toMatchObject({
			baseUom: "EA",
			isPhysical: false,
		});

		const pu = await db.query.productUom.findMany({
			where: eq(productUom.productId, createdProduct.id),
		});

		expect(pu).toEqual([]);
		expect(pu).toHaveLength(0);
	});

	it("get product stock", async () => {
		const stock = await ctx.caller.product.getStock({
			organizationId: ctx.defaultOrg.id,
			productId: "59b0e679-03a8-4115-ae31-b2dd085f1f8a",
			warehouseId: "d5f9b48d-d107-4a9b-a25a-61698f2a0fb4",
		});

		console.log(stock);

		expect(stock).toBeTruthy();
	});
});
