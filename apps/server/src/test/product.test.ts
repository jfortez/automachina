import { faker } from "@faker-js/faker";
import type { inferProcedureInput } from "@trpc/server";

import { eq } from "drizzle-orm";
import { nanoid } from "nanoid";
import { beforeAll, describe, expect, it } from "vitest";
import { db } from "@/db";
import { productUom } from "@/db/schema/products";
import type { AppRouter } from "@/routers";
import { setupTestContext } from "./util";

describe("Testing Product Route", () => {
	let ctx: Awaited<ReturnType<typeof setupTestContext>>;

	beforeAll(async () => {
		ctx = await setupTestContext();
	});
	describe("testing product category route", () => {
		it("get all categories", async () => {
			const categories = await ctx.caller.product.category.getAll();
			expect(categories).toBeTruthy();
		});

		it("get category by code", async () => {
			const category = await ctx.caller.product.category.getByCode("public");
			expect(category).toBeTruthy();
			expect(category).toHaveProperty("code", "public");
		});

		it.sequential("create a category", async () => {
			const newCategory = {
				code: "NEW_CATEGORY",
				name: "New Category",
			};
			const [createdCategory] =
				await ctx.caller.product.category.create(newCategory);
			expect(createdCategory).toBeTruthy();
			expect(createdCategory).toHaveProperty("code", newCategory.code);
		});

		it.sequential("update a category", async () => {
			const categoryToUpdate =
				await ctx.caller.product.category.getByCode("NEW_CATEGORY");

			if (!categoryToUpdate) {
				throw new Error("Category not found");
			}
			const { id } = categoryToUpdate;

			await ctx.caller.product.category.update({
				id: id,
				code: "UPDATED_CATEGORY",
				name: "Updated Category",
				description: "this category was updated",
			});

			const categoryUpdated = await ctx.caller.product.category.getById(id);

			expect(categoryUpdated).toBeTruthy();
			expect(categoryUpdated).toHaveProperty("code", "UPDATED_CATEGORY");
			expect(categoryUpdated).toHaveProperty("name", "Updated Category");
		});

		it.sequential("delete a category", async () => {
			const categoryToDelete =
				await ctx.caller.product.category.getByCode("UPDATED_CATEGORY");

			if (!categoryToDelete) {
				throw new Error("Category not found");
			}

			await ctx.caller.product.category.delete(categoryToDelete.id);

			const deletedCategory = await ctx.caller.product.category.getById(
				categoryToDelete.id,
			);
			expect(deletedCategory).toBeFalsy();
		});
	});

	it("create a single product with EA base UOM", async () => {
		const input: inferProcedureInput<AppRouter["product"]["create"]> = {
			baseUom: "EA",
			name: faker.commerce.productName(),
			description: faker.commerce.productDescription(),
			sku: nanoid(10),
			productUoms: [
				{
					uomCode: "EA",
					qtyInBase: "1",
				},
				{
					uomCode: "PK",
					qtyInBase: "6",
				},
				{
					uomCode: "BX",
					qtyInBase: "36",
				},
			],
			attributes: {
				foo: "bar",
			},
			categoryId: ctx.defaultCategoryId,
			trackingLevel: "none",
		};

		const createdProduct = await ctx.caller.product.create(input);

		expect(createdProduct).toBeTruthy();
	});

	it("create a product with autogenerated product Uoms using uomConversion", async () => {
		const input: inferProcedureInput<AppRouter["product"]["create"]> = {
			baseUom: "EA",
			name: faker.commerce.productName(),
			description: faker.commerce.productDescription(),
			sku: nanoid(10),
			productUoms: [
				{
					uomCode: "PK",
				},
			],
			categoryId: ctx.defaultCategoryId,
		};

		const createdProduct = await ctx.caller.product.create(input);

		const pu = await db.query.productUom.findMany({
			where: eq(productUom.productId, createdProduct.id),
		});

		expect(createdProduct).toBeTruthy();
		expect(pu).toBeTruthy();
		expect(pu).toHaveLength(2);

		const EaProductUom = pu.find((p) => p.uomCode === "EA");
		expect(EaProductUom).toBeTruthy();
		expect(EaProductUom).toMatchObject({
			uomCode: "EA",
			qtyInBase: "1.".padEnd(11, "0"),
			isBase: true,
		});

		const PkProductUom = pu.find((p) => p.uomCode === "PK");
		expect(PkProductUom).toBeTruthy();
		expect(PkProductUom).toMatchObject({
			uomCode: "PK",
			qtyInBase: "6.".padEnd(11, "0"),
		});
	});

	it("create a product without productUoms", async () => {
		const input: inferProcedureInput<AppRouter["product"]["create"]> = {
			baseUom: "EA",
			name: faker.commerce.productName(),
			description: faker.commerce.productDescription(),
			sku: nanoid(10),
			categoryId: ctx.defaultCategoryId,
		};

		const createdProduct = await ctx.caller.product.create(input);

		expect(createdProduct).toBeTruthy();
		expect(createdProduct).toMatchObject({
			baseUom: "EA",
			isPhysical: true,
		});

		const pu = await db.query.productUom.findMany({
			where: eq(productUom.productId, createdProduct.id),
		});

		expect(pu).toBeTruthy();
		expect(pu).toMatchObject([
			{
				uomCode: "EA",
				qtyInBase: "1.000000000",
				isBase: true,
			},
		]);
	});

	it("Create a product with no stock (like service)", async () => {
		const input: inferProcedureInput<AppRouter["product"]["create"]> = {
			baseUom: "EA",
			name: "THIS IS A SERVICE",
			description: "THIS IS A SERVICE PRODUCT",
			sku: nanoid(10),
			categoryId: ctx.defaultCategoryId,
			isPhysical: false,
		};

		const createdProduct = await ctx.caller.product.create(input);

		expect(createdProduct).toBeTruthy();
		expect(createdProduct).toMatchObject({
			baseUom: "EA",
			isPhysical: false,
		});

		const pu = await db.query.productUom.findMany({
			where: eq(productUom.productId, createdProduct.id),
		});

		expect(pu).toEqual([]);
		expect(pu).toHaveLength(0);
	});

	it.sequential("get product stock with breakdown", async () => {
		// First create a product with packaging UoM
		const productInput: inferProcedureInput<AppRouter["product"]["create"]> = {
			sku: nanoid(10),
			name: "Product with Packaging Breakdown",
			baseUom: "EA",
			trackingLevel: "none",
			isPhysical: true,
			categoryId: ctx.defaultCategoryId,
			productUoms: [
				{
					uomCode: "PK",
					qtyInBase: "6", // 1 PK = 6 EA
				},
			],
		};

		const createdProduct = await ctx.caller.product.create(productInput);

		// Add 25 EA stock (4 PK complete + 1 EA remaining = 25 EA)
		const receiveInput: inferProcedureInput<AppRouter["inventory"]["receive"]> =
			{
				productId: createdProduct.id,
				qty: 4,
				uomCode: "PK", // Receive 4 PK = 24 EA
				currency: "USD",
			};
		await ctx.caller.inventory.receive(receiveInput);

		const receiveInput2: inferProcedureInput<
			AppRouter["inventory"]["receive"]
		> = {
			productId: createdProduct.id,
			qty: 1,
			uomCode: "EA", // Receive additional 1 EA
			currency: "USD",
		};
		await ctx.caller.inventory.receive(receiveInput2);

		const stockWithBreakdown = await ctx.caller.product.getStock({
			productId: createdProduct.id,
			uomCode: "PK", // Request in packaging UoM
		});

		expect(stockWithBreakdown).toMatchObject({
			productId: createdProduct.id,
			totalQty: 4, // Math.floor(25 / 6) = 4 complete PK
			uomCode: "PK",
			breakdown: [
				{ uomCode: "PK", qty: 4 }, // 4 complete packages
				{ uomCode: "EA", qty: 1 }, // 1 remaining unit
			],
		});

		// Test getting stock in base UoM (no breakdown)
		const stockBaseUom = await ctx.caller.product.getStock({
			productId: createdProduct.id,
			uomCode: "EA", // Request in base UoM
		});

		expect(stockBaseUom).toMatchObject({
			productId: createdProduct.id,
			totalQty: 25,
			uomCode: "EA",
			breakdown: undefined, // No breakdown when requesting base UoM
		});

		// Test getting stock with no specific UoM (default behavior)
		const stockDefault = await ctx.caller.product.getStock({
			productId: createdProduct.id,
		});

		expect(stockDefault).toMatchObject({
			productId: createdProduct.id,
			totalQty: 25,
			uomCode: "EA",
			breakdown: undefined, // No breakdown when no UoM specified
		});
	});
});
